\documentclass[12pt,leqno]{article}

\usepackage[utf8x]{inputenc}
\usepackage{amssymb, upgreek}
\usepackage{lipsum}
\usepackage{adjustbox}
\usepackage{dsfont}
\usepackage{multicol}

\usepackage{color}
\definecolor{keywordcolor}{rgb}{0.7, 0.1, 0.1}   % red
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.0, 0.1, 0.6}    % blue
\definecolor{sortcolor}{rgb}{0.1, 0.5, 0.1}      % green
\definecolor{errorcolor}{rgb}{1, 0, 0}           % bright red
\definecolor{stringcolor}{rgb}{0.5, 0.3, 0.2}    % brown

\usepackage{listings}
\def\lstlanguagefiles{lstlean.tex}
\lstset{language=lean}

\def\lc{\lstinline}

\title{Formalising an Intuitionistic Type Theory in Lean}
\author{COMP30014 Research Project \\William Price, Student ID: 917093\\ Supervisors: Daniel Murfet, Toby Murray.}

\newcommand{\ITT}{\textbf{ITT}}
\newcommand{\LITT}{\textbf{LITT}}
\def\pow{\mathscr{P}}


% * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
% Daniel Stuff
% * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 


\usepackage{array}
\usepackage{stmaryrd}
\usepackage{amsmath, amscd, amssymb, mathrsfs, accents, amsfonts,amsthm}
% \usepackage[all]{xy}
% \usepackage{bussproofs}
% \usepackage{tikz}
% \usepackage{tikz-cd}
\usepackage{bbm}
\def\nicedashedcolourscheme{\shadedraw[top color=blue!22, bottom color=blue!22, draw=gray, dashed]}
\def\nicecolourscheme{\shadedraw[top color=blue!22, bottom color=blue!22, draw=white]}
\def\nicepalecolourscheme{\shadedraw[top color=blue!12, bottom color=blue!12, draw=white]}
\def\nicenocolourscheme{\shadedraw[top color=gray!2, bottom color=gray!25, draw=white]}
\def\nicereallynocolourscheme{\shadedraw[top color=white!2, bottom color=white!25, draw=white]}
\definecolor{Myblue}{rgb}{0,0,0.6}
\usepackage[a4paper,colorlinks,citecolor=Myblue,linkcolor=Myblue,urlcolor=Myblue,pdfpagemode=None]{hyperref}

\setlength{\evensidemargin}{0.1in}
\setlength{\oddsidemargin}{0.1in}
\setlength{\textwidth}{7in}
\setlength{\topmargin}{0.0in}
\setlength{\textheight}{8.5in}
\setlength{\headheight}{0in}


\newtheorem{theorem}{Theorem}[section]
\newtheorem{thm}[theorem]{Theorem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{cor}[theorem]{Corollary}
\newtheorem{setup}[theorem]{Setup}
\newtheorem{defn}[theorem]{Definition}
\newtheorem{algorithm}[theorem]{Algorithm}

% Labels in tabular
\newcommand{\tagarray}{\mbox{}\refstepcounter{equation}$(\theequation)$}

\newtheoremstyle{example}{\topsep}{\topsep}
  {}
  {}
  {\bfseries}
  {.}
  {2pt}
  {\thmname{#1}\thmnumber{ #2}\thmnote{ #3}}
  
  \theoremstyle{example}
  \newtheorem{definition}[theorem]{Definition}
  \newtheorem{example}[theorem]{Example}
  \newtheorem{remark}[theorem]{Remark}
  \newtheorem{desi}[theorem]{Desiderata}

\numberwithin{equation}{section}

% % Will stuff}
% \newcommand{\call}[1]{\mathcal{#1}}
% \newcommand{\psheaf}{\text{\underline{Set}}^{\scr{C}^{\text{op}}}}
% \newcommand{\und}[1]{\underline{\hspace{#1 cm}}}
% \newcommand{\adj}[1]{\text{\textopencorner}{#1}\text{\textcorner}}
% \newcommand{\comment}[1]{}

% % Operators
% \def\can{\operatorname{can}}
% \def\Hom{\operatorname{Hom}}
% \def\be{\begin{equation}}
% \def\ee{\end{equation}}
% \def\nN{\mathds{N}}
% \def\nZ{\mathds{Z}}
% \def\nQ{\mathds{Q}}
% \def\nR{\mathds{R}}
% \def\nC{\mathds{C}}
% \def\ldot{\,.\,}
% \def\typearrow{\Rightarrow}
% \def\FV{\operatorname{FV}}
% \def\jac{\operatorname{Jac}_W}
% \DeclareMathOperator{\id}{id}

% * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  

\begin{document}

\maketitle

\begin{abstract}
  Proofs in formal systems are inherently laborious, and it is difficult to present complete proofs within formal systems without completely sacrificing the presentation. We implement an intuitionistic type theory in Lean, an interactice proof assistant, and demonstrate its utility in guiding, automating and organising formal proofs.
\end{abstract}

\tableofcontents


\section{The Intuitionistic Type Theory}

\subsection{Lean Syntax}

Lean is an interactive theorem prover \cite{lean} based on the Calculus of Inductive Constructions\cite{carneiro} (CIC). In Lean, everything has a type, and we denote this relationship, \lc{a : A}, meaning \lc{a} has type \lc{A}. There is a type of types called \lc{Type}, a member of which is \lc{Prop}, so can write \lc{Prop : Type}. Any member of \lc{Type} can be defined to have members. In particular \lc{Prop} has members, which are propositions. 


\subsection{ITT vs. LITT}

We implement the intuitionistic type theory defined in Lambek and Scott, Introduction to Higher Order Categorical Logic \cite{lambek_scott}, which we abbreviate \ITT, with the exception that we do not include a type of natural numbers by default. We also made significant use of Daniel Murfet's notes on \ITT~in developing this type theory.

We abbreviate our Lean implentation of \ITT~by \LITT. Where the \ITT~construction describes an extendable type theory which can have more types, terms, deduction rules, and non-trivial identifications of types and terms, we implement only the underlying \emph{pure} type theory in \LITT.

There are many subtleties about the definitions related to use of variables in terms, which cannot be ignored in Lean, so our implementation diverges from Lambek and Scott in key places. We present both definitions of each concept in parallel in order to contextualise the decisions we make.



\subsubsection{Meta Theories}

A specification or discussion of a formal theory must always take place within some meta-theory. For example, it is not possible to make a statement like ``If $p$ and $q$ are propositions, then $p \Rightarrow q$ is a proposition'', without any a priori semantics behind concepts like ``If'', ``and'', ``then'' - and a structural understanding of such statements. Once you have a formal system, it is then possible to specify and discuss other formal systems within it, and possibly even vice-versa. So how do you get started? Essentially you have to rely on intuitively meaningful and simple decision procedures, such as the rule above concerning proposition constructions. This is the notion of ``effective computability'' and is the subject of the Church Turing thesis. For this project, our meta-theory is the formal system, Lean, so these decision procedures are well-defined.

It is worth paying attention to the strength of the meta-theory used to specify a formal system, and what features we may be asking of the meta-theory without realising. For example, one usually expects to produce as many fresh ``variables'' as one needs when manipulating terms. Is this a reasonable expectation? Maybe, maybe not, but it is worth spotlighting such manners. We benefit from studying one formal system within another by making such subtleties explicit. In order to not overshadow the main intentions with definitional subtleties, we present both the intuitive, \ITT~definitions, and the concrete \LITT~definitions of each concept (though some are unique to \LITT).

Our type theory manifests in Lean via 4 inductively defined types, the first of which is the type of types. Lean itself already has a type \lc{Type}, so we use the lowercase, \lc{type}, for the type of types in our theory. The relationship here is \lc{type : Type}, i.e. ``the type of \lc{type} is \lc{Type}''.

Since Lean has an extensible parser, for each definition, we define unicode-based notation to make the syntax more readable. Examples will follow where needed.

\begin{definition}(\textbf{ITT})
  A type theory has a class of \emph{types}, including basic types $\Omega, \mathds{1}$, closed under the following constructions
  \begin{itemize}
    \item If $A$ is a type then $\mathscr{P}A$ is a type
    \item If $A,B$ are types then $A \times B$ is a type
  \end{itemize}

  These types will be inhabited by \emph{terms/variables}, and we introduce this relationship $a : A$, meaning $a$ is a term/variable of type $A$. For each type $A$, there is an unlimited supply of \emph{variables}, $x : A$.

  $\Omega$ is thought of as the type of propositions, and $\mathds{1}$ will have a unique inhabitant (up to provable equivalence).
\end{definition}

\begin{definition}(\textbf{LITT})
\begin{lstlisting}[frame=single]
/- The inductive definition of a `type`-/
inductive type : Type
| Unit | Omega | Prod (A B : type)| Pow (A : type)
\end{lstlisting}
Working within lean, we refine the a priori notion of a ``class'' of types to mean a \lc{Type} called \lc{type}, which is inductively defined via four constructors. The first two take no arguments (they are basic members of \lc{type}), and the other two construct new types from old ones. We also define related notation. 
\begin{lstlisting}
notation `Î©` := type.Omega
notation `ğŸ™` := type.Unit
infix `Ã—`:max := type.Prod
notation `ğ’«`A :max := type.Pow A

#check type.Prod type.Omega (type.Pow type.Unit) -- type
#check Î© Ã— (ğ’« ğŸ™) -- type
\end{lstlisting}
\end{definition}

It's important to note that there is no semantic content in either definition. Nothing yet constrains the Unit type to only have one member, nor the Omega type to be logical, nor the powerset or product constructors to ``make'' the new type from old ones. It's only once we declare what constitutes a ``proof'' statement involving terms of these types that they adopt a consistent meaning. The only feature we get at this point is definitional inequality between types with different derivations, meanining there are no non-trivial identifications between types such as \lc{Pow Unit} and \lc{Omega}.

\begin{definition}(\textbf{LITT})
  \label{LSterm}
  A type theory has a class of \emph{terms}\footnote{One should actually define \emph{preterms} as we define \emph{terms} and then account for $\alpha$-equivalence (see \ref{section:variables}). We skip this discussion (noting we are defining ``too many'' terms) as our Lean interpretation avoids the need for $\alpha$-equivalence altogether.}, and to each is associated a unique \emph{type}. We denote this relationship, $a : A$, meaning $a$ is of type $A$. The class of terms is closed under the following constructions (which can also be performed on variables). Let $A, B$ be types and $(a : A)$, $(b : B)$, $(\alpha : \mathscr{P} A)$, $(p, q, \varphi : \Omega)$.
  \setlength{\columnsep}{-3cm}
  \begin{multicols}{2}
    {\large\textbf{Basic Terms}}
    \begin{itemize}
      \item $\ast : \mathds{1}$ (``star'')
      \item $\top : \Omega$ (``true/top'')
      \item $\bot : \Omega$ (``false/bottom'')
    \end{itemize}
    
    {\large\textbf{Propositional connectives}}~
    \begin{itemize}
      \item $p \wedge q : \Omega$ (``conjunction'')
      \item $p \vee q : \Omega$ (``disjunction'')
      \item $p \Rightarrow q : \Omega$ (``implication'')
      \item $a \in \alpha : \Omega$ (``elementhood'')
    \end{itemize}

    \columnbreak
    
    {\large\textbf{Quantifiers}}~

    Let $x$ be a variable of type $A$.
    \begin{itemize}
      \item $(\forall x \in A)~\varphi : \Omega$ (``Universal Quantification'')
      \item $(\exists x \in A)~\varphi : \Omega$ (``Existential Quantification'')
      \item $\{x \in A \mid \varphi\} : \mathscr{P} A$ (``Set Comprehension'')
    \end{itemize}
    
    {\large\textbf{Pairs}}
    \begin{itemize}
      \item $\langle a, b \rangle : A \times B$
    \end{itemize}
  \end{multicols}
\end{definition}

It is worth understanding the quantifier constructions in greater detail, as there is potential for confusion in the use of the $\in$-elementhood symbol.

Let $A$ be a type, $x$ a variable of type $A$ and $\varphi : \Omega$. Note that $\varphi$ may or not contain $x$ as a free variable (see \ref{section:variables}). Then the following are also terms,
\begin{itemize}
  \item ${\color{red}(\forall } x~ { \color{red} \in~ }  A {\color{red})}~\varphi : \Omega$ (``Universal Quantification'')
  \item ${\color{red}(\exists }x~ {\color{red} \in~} A{\color{red})}~\varphi : \Omega$ (``Existential Quantification'')
  \item ${\color{red}\{}x~ {\color{red}\in}~ A~ {\color{red}\mid}~  \varphi {\color{red}\}} : \mathscr{P} A$ (``Set Comprehension'')
\end{itemize}
We have highlighted in red the purely-syntactic content introduced by each construction. In particular, the $\in$ in $\forall x \in A$ should not be confused with the elementhood propositional connective. It is purely a syntactical feature to which indicates the type of the variable $x$ being quantified over.

An important subtlety is that in declaring that the variable $x$ has type $A$, we are assuming any appearance of a variable with name $x$ is actually the same variable with the same type, $A$. More correctly, each type has (by meta-theoretical assumption) an unlimited supply of variables of each type, and to each such variable is associated a unique type. In practice we would allow the use of a variable name with different types, just not within the same term (or arrangement of terms to be safe). However, we will need to be more careful once Lean is our metatheory.

\subsection{Variables}\label{section:variables}
% Todo discuss variables
\begin{definition}(\textbf{ITT})
  To each term $\alpha$ we associate a finite set $FV(\alpha)$ called the \emph{free variables} of $\alpha$. This set is defined recursively as follows.
  \begin{multicols}{2}
    \begin{itemize}
      \item $FV(\ast) = \emptyset$
      \item $FV(\top) = \emptyset$
      \item $FV(\bot) = \emptyset$
      \item $FV(p \wedge q) = FV(p) \cup FV(q)$
      \item $FV(p \vee q) = FV(p) \cup FV(q)$
      \item $FV(p \Rightarrow q) = FV(p) \cup FV(q)$
      \item $FV(a \in \alpha) = FV(a) \cup FV(\alpha)$
      \item $FV((\forall x \in A)\varphi) = FV(\varphi) \setminus \{x\}$
      \item $FV((\exists x \in A)\varphi) = FV(\varphi) \setminus \{x\}$
      \item $FV(\{ x \in A \mid \varphi\}) = FV(\varphi) \setminus \{x\}$
    \end{itemize}
  \end{multicols}

  Within the term $\phi$, the free occurences of the variable $x$ are said to be \emph{captured} by a quantifier in the expressions $(\forall x \in A)\varphi$, $(\exists x \in A)\varphi$, $\{ x \in A \mid \varphi\}$. A term with no variables is called \emph{closed}.
\end{definition}

\begin{definition}(\textbf{ITT})
  For any term $\varphi$ and variables $x, y$ of some type, by $\varphi[y / x]$, we mean the resulting term when all free occurences of $x$ are replaced with $y$.

  We define an equivalence relation $=_\alpha$ as the smallest equivalence relation on terms, closed under all term-formation rules, and for any variables $x, y : A$, $\varphi : \Omega$,
  \begin{itemize}
    \item $(\forall x \in A)\varphi =_\alpha (\forall y \in A)\varphi[y / x]$
    \item $(\exists x \in A)\varphi =_\alpha (\forall y \in A)\varphi[y / x]$
    \item $\{ x \in A \mid \varphi\} =_\alpha \{ x \in A \mid \varphi[y / x]\}$
  \end{itemize}
  as long as no free occurence of $x$ would become captured by a quantifier in $\varphi[y / x]$.
\end{definition}

It is necessary to form $\alpha$-equivalence classes of the terms (they would be called preterms) we defined in \ITT, in order to identify (what we intend to be) semantically equivalent terms. Alternatively, we could leave $\alpha$-equivalent terms distinct, and add a proof-formation rule that allows conversion between such terms. In practice (in \LITT) we avoid the need for $\alpha$-equivalence entirely by using De Bruijn indices.

\subsection{De Bruijn Indices}

The usual named-variable approach to quantification excels in readability, but lacks canonicity. Consider the $\alpha$-equivalent terms $\varphi_1 = \{ x_1 \in A \mid (\exists y_1 \in A) (\forall z_1 \in A) \dots x_1 \dots z_1 \dots y_1 \}$, and $\varphi_2 = \{ x_2 \in A \mid (\exists y_2 \in A) (\forall z_2 \in A) \dots x_2 \dots z_2 \dots y_2 \}$ denoting some quantified terms where $x_1,y_1,z_1,x_2,y_2,z_2$ are free variables that become captured by the shown quantifiers. If we pay attention to the structure of these expressions, we notice we can canonically name each variable by the index counting the number of quantifiers structurally ``between'' each variable and its quantifier (given only one occurence of that variable). Essentially, each variable ``points'' to its intended quantifier, and we remove the naming at the quantifer itself in order to account for multiple instances of the same variable at different \emph{depths}. Our resulting term looks like this, and the indices used here are called De Bruijn indices \cite{pierce}.
\[\{ A \mid (\exists A) (\forall A) \dots 2 \dots 0 \dots 1 \}\]

Note now that the syntax of the inner terms are not yet typed - the index chooses which quantifier will capture it's variable, and the quantifier decides the type of the variable. With the goal of eliminating the need for the $\alpha$-equivalence via De Bruijn indices, this motivates the type-less terms we introduce in LITT.

\begin{definition}(\textbf{LITT})
  \begin{lstlisting}[frame=single]
  inductive term : Type
  | star : term
  | top  : term
  | bot  : term
  | and  : term â†’ term â†’ term
  | or   : term â†’ term â†’ term
  | imp  : term â†’ term â†’ term
  | elem : term â†’ term â†’ term
  | pair : term â†’ term â†’ term
  | var  : â„• â†’ term
  | comp : type â†’ term â†’ term
  | all  : type â†’ term â†’ term
  | ex   : type â†’ term â†’ term
  \end{lstlisting}

  Here we define the \lc{Type} of terms. Note that the constructors here are largely independent of \lc{type}, which is odd, since it is natural to define terms along with the type that they inhabit, as we did in \ref{LSterm}. The lack of this constraint allows the creation of ill-formed terms such as \lc{and star star} (but not things like \lc{and star ex} - since that does not type-check).

  We would like to say something akin to the meta-theoretic \lc{star : Unit}. The problem here is that \lc{Unit : type} is a member of the type \lc{type : Type}, but is not a type itself, so we cannot construct members of it.

  There are two solutions here. We could parametrise \lc{term} by \lc{type}, such that \lc{term : type â†’ Type}, and allowing each constructor to constrain the \lc{type} of the input terms, for example \lc{pair (A B): term A â†’ term B â†’ term (A Ã— B)} and \lc{star : term Unit}. However, the former solution would require the \lc{term.var} constructor to decide on a \lc{type}, which can't be known until it is quantified over - so we run into the same issue. In order to simplify and separate the \emph{grammar} of terms and \emph{well-formedness} of terms, we allow untyped construction of terms and where necessary, require a proof of its well-formedness.

  Accompanying these constructors are notational shorthands.\footnote{Some of these symbols are reserved in Lean, and in practice we actually use slight variations, but we present the most ideal notation here.} Since some of these notational operators place input terms within quantifiers, we need to \emph{lift} the free-variables (uncaptured de-bruijn indices) in the term to avoid unintended capture. We provide only the type signature of \lc{lift} here (a more in depth discussion of lifting can be found in \cite{pierce}
  ). 
  \begin{lstlisting}
  notation `â‹†` := term.star
  notation `âŠ¤` := term.top
  notation `âŠ¥` := term.bot
  infix ` âˆ§ ` :50 := term.and
  infix ` âˆ¨ ` :50 := term.or
  infix ` âŸ¹ `:50 := term.imp

  def iff (p q: term) := (p âŸ¹ q) âˆ§ (q âŸ¹ p)
  infix ` â‡” `:50 := iff

  infix âˆˆ := term.elem
  notation `{ ` A ` | ` Ï† ` }` := term.comp A Ï†

  notation `âŸ¨` a `,` b `âŸ©` := term.pair a b 

  notation `âˆ€` := term.all
  notation `âˆƒ` := term.ex

  /- Coerce natural numbers to variables -/
  instance nat_coe_var : has_coe â„• term := âŸ¨term.varâŸ©

  -- Now we can write (term.var 0) as just â†‘0
  #reduce âˆƒ Î© â†‘0 -- term.all type.Omega (term.var 0)
  #reduce â†‘1 âˆ¨ âˆƒ Î© â†‘2 -- term.or (term.var 1) (term.ex type.Omega (term.var 2))

  -- `lift d k Ï†` increases all variable indices in `Ï†' at least `k' by `d'
  def lift (d : â„•) : â„• â†’ term â†’ term := sorry
  notation `^` := lift 1 0

  -- Leibniz equality
  def eq (A:type) (aâ‚ aâ‚‚ : term) : term
    := âˆ€ (ğ’« A) $ ((^ aâ‚) âˆˆ â†‘0) â‡” ((^ aâ‚‚) âˆˆ â†‘0)
  notation a ` â‰ƒ[`:max A `] `:0 b := eq A a b
  
  -- example
  #reduce â†‘2 â‰ƒ[ğŸ™] â†‘0  -- âˆ€ (ğ’« ğŸ™) ( (â†‘3 âˆˆ â†‘0) â‡” (â†‘1 âˆˆ â†‘0) )
  
  -- `subst n b Ï†` replaces the `n`th free variable in `Ï†` by `b`
  def subst : â„• â†’ term â†’ term â†’ term
    := sorry -- definition ommitted
  notation  `[` Ï† ` / `  b `]` := subst 0 b Ï†

  -- examples
  constants p q r : term
  #reduce p âˆ§ (q âˆ¨ r) -- term.and p (term.or q r)
  #reduce âˆƒ ğŸ™ ([â†‘0 / p] âˆ§ âˆ€ ğŸ™ (â†‘1 â‰ƒ[ğŸ™] â†‘0))
    -- term.ex type.Unit (term.and p (term.all (type.Pow type.Unit) (iff (term.elem (term.var 2) (term.var 0)) (term.elem (term.var 1) (term.var 0)))))
  \end{lstlisting}

\end{definition}

\begin{definition}
  \label{def:LITTWF}
  We inductively define a family of meta-theoretic propositions, that is, members of \lc{Prop}\footnote{\lc{Prop} is the type of Propositions in Lean - it's the meta-theoretic equivalent of $\Omega$. Members \lc{P : Prop} are propositions, and members \lc{p : P} are proofs of \lc{P}}. The parameters that appear in braces on the left side of each \lc{:}, are dependent types to the type of each constructor.\footnote{These are implicit arguments to the constructor, and are inferred other arguments provided to the constructor.}
  
  \begin{lstlisting}[frame=single]
  def context : list type
  
  inductive WF : context â†’ type â†’ term â†’ Prop
  | star {Î“}         : WF Î“ ğŸ™ â‹†
  | top  {Î“}         : WF Î“ Î© âŠ¤
  | bot  {Î“}         : WF Î“ Î© âŠ¥
  | and  {Î“ p q}     : WF Î“ Î© p â†’ WF Î“ Î© q â†’ WF Î“ Î© (p âˆ§ q)
  | or   {Î“ p q}     : WF Î“ Î© p â†’ WF Î“ Î© q â†’ WF Î“ Î© (p âˆ¨ q)
  | imp  {Î“ p q}     : WF Î“ Î© p â†’ WF Î“ Î© q â†’ WF Î“ Î© (p âŸ¹ q)
  | elem {Î“ A a Î±}   : WF Î“ A a â†’ WF Î“ (ğ’« A) Î± â†’ WF Î“ Î© (a âˆˆ Î±)
  | pair {Î“ A B a b} : WF Î“ A a â†’ WF Î“ B b â†’ WF Î“ (A Ã— B) âŸ¨a,bâŸ©
  | var  {Î“ A n}     : (Î“.nth n = some A) â†’ WF Î“ A (var n)
  | comp {Î“ A Ï†}     : WF (A::Î“) Î© Ï† â†’ WF Î“ (ğ’« A) {A | Ï†}
  | all  {Î“ A Ï†}     : WF (A::Î“) Î© Ï† â†’ WF Î“ Î© (âˆ€ A Ï†)
  | ex   {Î“ A Ï†}     : WF (A::Î“) Î© Ï† â†’ WF Î“ Î© (âˆƒ A Ï†)
  \end{lstlisting}

  Given \lc{Î“ : context}, \lc{A : type}, \lc{a : term}, we have just defined \lc{WF Î“ A a} to be the proposition that \lc{a} is a well-formed term of type \lc{A} in context \lc{Î“}. Each constructor produces a member of some \lc{WF Î“ A a}, that is, a \emph{proof} of \lc{WF Î“ A a}. For example, given any context, we can summon a proof that \lc{â‹†} is well-formed of type \lc{ğŸ™} in that context just by declaring \lc{WF.star}. Well-formedness proofs of terms made from propositional connectives (and pairs) require proofs that each term is well-formed in the same context.
  
  \vspace{0.1in}
  \noindent{\large \textbf{What is a context?}}

  Since De Bruijn index-variables are not typed, we must use provide a mapping of free-variable-indices to types, in order to prevent conflicting types among variables when quantifying. Since such a mapping is just a function \lc{[n] â†’ type} for some natural number \lc{n}, we can just a use a list of types, where the De Bruijn index \lc{n} maps to the nth type in the list. To introduce a proof that a variable term of some \lc{A : type} is well-formed via \lc{WF.var : (Î“.nth n = some A) â†’ WF Î“ A (var n)}, we must provide a proof that the n'th type in the context is infact \lc{A}. To introduce a proof that a quantified statement like \lc{âˆ€ A Ï†} is well-formed of type \lc{Î©}, we must provide a proof that \lc{Ï†} is well-formed to \lc{WF.all}, where \lc{A} is appended to the start of the context - so any variable captured by this quantifier has type \lc{A}.\footnote{This also lifts all other variables in the context, to correspond to deeper De-Bruijn indices, since we have passed through a quantifier.} Similar constructions apply to the existential and set-comprehension constructions.
\end{definition}

\begin{definition}
  Given a finite set $\Gamma$ of free-variables of any types, an \ITT~has a relation, $\Gamma$-entailment, on pairs of propositional terms $\varphi, \psi : \Omega$, such that $FV(\varphi), FV(\psi) \subseteq \Gamma$. We write such a relation $\varphi \vdash_\Gamma \psi$, and abbreviate $\varphi \vdash_\emptyset \psi$ to $\varphi \vdash \psi$, $\top \vdash_\Gamma \psi$ to $\vdash_\Gamma \psi$ and $\top \vdash \psi$ to $\vdash \psi$.

  Such a $\Gamma$-entailment must contain certain axiomatic relations, as well as certain deduction rules which each determine that entailment can be deduced from one or more other entailments. We do not state them all here, as they will just be repeated in the next definition.

  A \emph{proof} of some $\Gamma$-entailment, $\varphi \vdash_\Gamma \psi$ is a deduction tree beginning with one or more axiomatic relations.
\end{definition}
  


\begin{definition}(\textbf{LITT})

  \label{def:LITT:entails}
  We define $\Gamma$-entailment $\varphi \vdash_\Gamma \psi$ as the inductively defined relation \lc{entails : context â†’ term â†’ term â†’ Prop}. 
\begin{lstlisting}[basicstyle=\small\ttfamily, frame=single]
inductive entails : context â†’ term â†’ term â†’ Prop
| axm        {Î“} {p}       : WF Î“ Î© p â†’ entails Î“ p p
| vac        {Î“} {p}       : WF Î“ Î© p â†’ entails Î“ p âŠ¤
| abs        {Î“} {p}       : WF Î“ Î© p â†’ entails Î“ âŠ¥ p
| and_intro  {Î“} {p q r}   : entails Î“ p q â†’ entails Î“ p r â†’ entails Î“ p (q âˆ§ r)
| and_left   {Î“} (p q r)   : entails Î“ p (q âˆ§ r) â†’ entails Î“ p q
| and_right  {Î“} (p q r)   : entails Î“ p (q âˆ§ r) â†’ entails Î“ p r
| or_intro   {Î“} {p q r}   : entails Î“ p r â†’ entails Î“ q r â†’ entails Î“ (p âˆ¨ q) r
| or_left    {Î“} (p q r)   : entails Î“ (p âˆ¨ q) r â†’ entails Î“ p r
| or_right   {Î“} (p q r)   : entails Î“ (p âˆ¨ q) r â†’ entails Î“ q r
| imp_to_and {Î“} {p q r}   : entails Î“ p (q âŸ¹ r) â†’ entails Î“ (p âˆ§ q) r
| and_to_imp {Î“} {p q r}   : entails Î“ (p âˆ§ q) r â†’ entails Î“ p (q âŸ¹ r)
| weakening  {Î“} {p q Î”}   : entails Î“ p q â†’ entails (Î“ ++ Î”) p q
| cut        {Î“} (p c q)   : entails Î“ p c â†’ entails Î“ c q â†’ entails Î“ p q
| all_elim   {Î“} {p Ï† A}   : entails Î“ p (âˆ€ A Ï†) â†’ entails (A::Î“) (^p) Ï†
| all_intro  {Î“} {p Ï†} (A) : entails (A::Î“) (^p) Ï† â†’ entails Î“ p (âˆ€ A Ï†)
| ex_elim    {Î“} {p Ï† A}   : entails Î“ p (âˆƒ A Ï†) â†’ entails (A::Î“) (^p) Ï†
| ex_intro   {Î“} {p Ï†} (A) : entails (A::Î“) (^p) Ï† â†’ entails Î“ p (âˆƒ A Ï†)

/- equality of powerset terms is determined by elementhood  (dollar signs make application right-associative for less brackets)-/
| extensionality {A} : entails [] âŠ¤
                       $  âˆ€ (ğ’« A) $ âˆ€ (ğ’« A) $ âˆ€ A 
                       $ ((â†‘0 âˆˆ â†‘2) â‡” (â†‘0 âˆˆ â†‘1)) âŸ¹ (â†‘1 â‰ƒ[ğ’« A] â†‘0)

/- Provably equivalent propositions are equal -/
| prop_ext : entails [] âŠ¤ $ âˆ€[Î©,Î©] $ (â†‘1 â‡” â†‘0) âŸ¹ (â†‘1 â‰ƒ[Î©] â†‘0)

/- â‹† is unique up to provable equivalence -/
| star_unique : entails [] âŠ¤ $ âˆ€ ğŸ™ (â†‘0 â‰ƒ[ğŸ™] â‹†)

/- Any term of a product type has a pair representation -/
| pair_rep {A B} : entails [] âŠ¤
                   $ âˆ€ (A Ã— B) $ âˆƒ[A,B] $ â†‘2 â‰ƒ[A Ã— B] âŸ¨â†‘1,â†‘0âŸ©

/- Terms of product type are distinguished pairwise -/
| pair_distinct {A B} : entails [] âŠ¤
                        $ âˆ€ A $ âˆ€ B $ âˆ€ A $ âˆ€ B
                        $ (âŸ¨â†‘3,â†‘2âŸ© â‰ƒ[A Ã— B] âŸ¨â†‘1,â†‘0âŸ©)
                          âŸ¹ ((â†‘3 â‰ƒ[A] â†‘1) âˆ§ (â†‘2 â‰ƒ[B] â†‘0))

/- Entailments on free variables hold for any well-formed substitution -/
| sub        {Î“} (B b p q) : WF Î“ B b
                             â†’ entails (B::Î“) p q
                             â†’ entails Î“ [p / b] [q / b]

/- Set comprehension terms are populated precisely by all terms satisfying the condition   
   Note: we must lift { A | Ï† } so it doesn't have â†‘0 free -/
| comp       {Î“} (A Ï†)     : WF (A::Î“) Î© Ï† â†’ entails Î“ âŠ¤ (âˆ€ A
                             $ (â†‘0 âˆˆ (^ { A | Ï† })) â‡” Ï†))
\end{lstlisting}

Things to note:
\begin{itemize}
  \item The role of the finite set of free variables $\Gamma$, from which both associated terms must source their free-variables from, is now fulfilled by a \lc{context}, which we defined earlier to establish well-formedness on terms.
  \item Of the 24 constructors, only 5 request a proof of well-formedness of any of the terms appearing in the resulting entailment. These 5 are exactly those through which a new term can be introduced, after which well-formedness is preserved between proofs. The relevant theorem here can be stated and proved precisely in Lean, as we demonstrate in \ref{section:WF_proof_terms}.
\end{itemize}

We introduce notation for \lc{entails}. The double turnstile we use is usually distinguished from the single turnstile to represent truth in a model - but our usage is to avoid confusion with Lean's own usage for presenting goals (see \ref{section:tacticProofs}).

\begin{lstlisting}
prefix `âŠ¨`:1 := entails [] âŠ¤
infix ` âŠ¨ `:50 := entails []

-- Allows the parser to directly extract the context list
notation Ï†` âŠ¨[` Î“:(foldr `,` (h t, list.cons h t) list.nil) `] ` Ïˆ := entails Î“ Ï† Ïˆ
notation `âŠ¨[` Î“:(foldr `,` (h t, list.cons h t) list.nil) `] ` Ïˆ := entails Î“ âŠ¤ Ïˆ

variables p q Ï† Ïˆ : term

#reduce   âŠ¨ (p âˆ¨ Â¬p)  -- entails [] âŠ¤ (or p (imp p âŠ¥))
#reduce q âŠ¨ (p âˆ¨ Â¬p)  -- entails [] q (or p (imp p âŠ¥))
#reduce   âŠ¨[Î©,ğŸ™] p    -- entails [Î©, ğŸ™] âŠ¤ p
#reduce q âŠ¨[Î©,ğŸ™] p    -- entails [Î©, ğŸ™] q p
\end{lstlisting}
\end{definition}

\subsection{Semantics}

Through definition \ref{def:LITT:entails}, we have introduced a means of making assertions about well-formed terms in the type theory. For example, given any term \lc{Ï† : term}, as long as we can produce an \lc{h : WF [] Î© Ï†} (a proof of its well-formedness in the empty context), we can construct a proof of entailment proposition \lc{Prop}, \lc{entails [] Ï† Ï†} (the ITT entailment $\varphi \vdash \varphi$), like this:
\begin{lstlisting}
  lemma phi_ent_phi : entails [] Ï† Ï† := entails.axm h
\end{lstlisting}
Similarly, we can also construct a proof of \lc{entails [] Ï† âŠ¤}, like this:
\begin{lstlisting}
  lemma phi_ent_top : entails [] Ï† âŠ¤ := entails.vac h
\end{lstlisting}
Using both of these, we can show \lc{entails [] Ï† (Ï† âˆ§ âŠ¤)}.
\begin{lstlisting}
  lemma phi_ent_phi_and_top : entails [] Ï† (Ï† âˆ§ âŠ¤)
    := entails.and_intro phi_ent_phi phi_ent_top
\end{lstlisting}

Although it's called \lc{entails} - what makes \lc{entails Î“ Ï† Ïˆ} \emph{mean} entailment of \lc{Ïˆ} from \lc{Ï†} in context \lc{Î“}, and what it the logical content of the associated terms? For now, it's just some parametrised proposition - which can be proven for some term parameters via the constructors. One perspective is to first trust that the term constructions mean what we think they mean, and that well-formed terms of type \lc{Î©} are in fact propositions. This interpretation then justifies viewing the entailment constructors as valid deduction rules about entailment, including \lc{entails.and_intro} used in the above example. If we inductively suppose the intended meaning of \lc{entails [] Ï† Ï†} and \lc{entails [] Ï† âŠ¤}, then proofs of these constitute a proof \lc{entails [] Ï† (Ï† âˆ§ âŠ¤)}.

Alternatively, we can trust the intended meaning of \lc{entails Î“ Ï† Ïˆ} (and \lc{Î©}), and then interrogate each term construction and derive their meaning from the way they can appear in provable entailments. For example, we can derive the meaning of \lc{âˆ§} (which is \lc{term.and}) via the following constructors.
\begin{lstlisting}[basicstyle=\small\ttfamily]
entails.and_intro {Î“} {p q r} : entails Î“ p q â†’ entails Î“ p r â†’ entails Î“ p (q âˆ§ r)
entails.and_left  {Î“} (p q r) : entails Î“ p (q âˆ§ r) â†’ entails Î“ p q
entails.and_right {Î“} (p q r) : entails Î“ p (q âˆ§ r) â†’ entails Î“ p r
\end{lstlisting}

This injection of semantics into terms and entailment happens simultaenously - neither is prior. %TODO finish sentence

\section{Proofs in LITT}

Formal proofs of entailment in \ITT~are inherently laborious. The axioms and rules of deduction are presented minimally and serve only the purpose of forcing an interpretable meaning onto terms, and many ``obvious'' consequences of this interpretation require decent sized proofs supporting them. Upon attempting to perform a proof of any theorem with substantial ``logical content'', it is impossible to avoid frequent detours in proving various associated lemmas. Such lemmas are frequently ``obvious'', and it becomes extremely tempting to leave them out altogether, in order to not distract from the central proof.

Since a key point of studying formal systems is demonstrating their ability to % TODO

\subsection{Tactic Proofs}\label{section:tacticProofs}

Typically, a proof is constructed backwards, that is, starting at the conclusion, recognising if the conclusion is an axiom, and otherwise applying some deduction rule in reverse to produce one or more new ``sub-conclusions''/``goals'' to prove. Repeating this process (intelligently), if we eliminate all of the goals as axioms, we can terminate and claim a proof.

This describes exactly the process of performing an interactive \emph{tactic proof} in Lean. At each point in the proof, Lean presents us with the current goal to prove, and we can invoke any constructor or lemma whose conclusion can be unified with the goal. As an example, we prove \lc{lemma phi_ent_phi_and_top : entails [] Ï† (Ï† âˆ§ âŠ¤)} again.

\begin{lstlisting}[numbers=left, stepnumber=1, frame=single]
lemma phi_ent_phi_and_top (h : WF [] Î© Ï†): Ï† âŠ¨ (Ï† â‹€ âŠ¤) :=
begin
  apply entails.and_intro,
  apply entails.axm,
  exact h,
  apply entails.vac,
  exact h
end
\end{lstlisting}

The tactic environment appears between \lc{begin} and \lc{end}. At the beginning of line 3, we are presented with this goal state in a separate windows.
\begin{lstlisting}[frame=single]
  1 goal
  Ï† : term,
  h : WF [] Î© Ï†
  âŠ¢ Ï† âŠ¨ Ï† â‹€ âŠ¤
\end{lstlisting}
It outlines the two hypotheses we have access to (that \lc{Ï†} is a term and \lc{h} is a proof of its well-formedness) and the goal we need to prove, \lc{Ï† âŠ¨ Ï† â‹€ âŠ¤}. After applying \lc{entails.and_intro : entails Î“ p q â†’ entails Î“ p r â†’ entails Î“ p (q âˆ§ r)}, the goal is unified with the conclusion and is replaced with two goals, which are exactly the (unified) hypotheses needed to apply \lc{entails.intro}.
% \begin{center}
% \begin{tabular}{c}
\begin{lstlisting}[frame=single]
  2 goals
  Ï† : term,
  h : WF [] Î© Ï†
  âŠ¢ Ï† âŠ¨ Ï†
  
  Ï† : term,
  h : WF [] Î© Ï†
  âŠ¢ Ï† âŠ¨ âŠ¤
\end{lstlisting}
% \end{tabular}
% \end{center}

The tactic proof then applies the relevant constructors as needed to solve the resulting goals, and the proof \lc{h} of the hypotheses \lc{WF [] Î© Ï†} is applied as needed.

This environment for theorem proving allows us to control the non-linearity of much larger proofs, since the task of keeping track of auxilliary goals to prove is handled entirely by Lean, and we can just deconstruct and prove each goal as they are presented. Another powerful programming pattern we can utilise is the organisation of ``helper-functions'' (lemmas) into libraries. Whenever we are presented a goal which is ``obvious'', we can extract it out as a \lc{lemma} and invoke it directly (sometimes automatically) in the tactic proof. Such techniques allow us to construct proofs of entailments which are both focused and clean in their presentation (sidelining trivial sub-goals), while still being completely formally verified.

\subsection{Automated Well-Formedness Proofs}

We demonstrate the power of interactive theorem proving by largely automating the process of proving well-formedness, which arises frequently when proving entailment. Suppose we want to prove, from some \lc{A : type}, that the conclusion term of the extensionality axiom is a closed well-formed term. We demonstrated half of the proof of this lemma here,
\begin{lstlisting}
lemma WF.extensionality {A : type} : WF [] Î© $ âˆ€' (ğ’« A) $ âˆ€' (ğ’« A) $ (âˆ€' A $ (â†‘0 âˆˆ â†‘2) â‡” (â†‘0 âˆˆ â†‘1)) âŸ¹ (â†‘1 â‰ƒ[ğ’« A] â†‘0)
  :=
  begin
    apply WF.all, apply WF.all, apply WF.imp,
      { apply WF.all, apply WF.and,
        { apply WF.imp,
          { apply WF.elem,
            -- refl solves equalities which are definitionally equal
            -- in this case `âŠ¢ [A, ğ’« A, ğ’« A].nth 0 = some A`
            apply WF.var, refl,
            apply WF.var, refl },
          { apply WF.elem,
            apply WF.var, refl,
            apply WF.var, refl }
        },
        { apply WF.imp,
          { apply WF.elem,
            apply WF.var, refl,
            apply WF.var, refl },
          { apply WF.elem,
            apply WF.var, refl,
            apply WF.var, refl }
        },
      },
    sorry -- Goal is : `âŠ¢ WF [ğ’« A, ğ’« A] Î© (â†‘1 â‰ƒ[ğ’« A] â†‘0)`'
  end
\end{lstlisting}

This becomes intractable to have to manually construct such a proof for every term of substantial structure. The key observation is that there is a canonical choice of well-formedness constructor to apply at each step of these proofs. This makes it appropriate to use one of Lean's many \emph{tactics}, called \lc{apply_rules}, which takes a list of rules and repeatedly calls \lc{apply} with the appropriate rule until it can no longer make progress.\footnote{It also looks in the goal state for proofs for hypotheses which are precisely the goal to be proven.}

By tagging all of the constructors with a \lc{WF_rules} identifier, we can reduce the previous proof to the following.

\begin{lstlisting}
lemma WF.extensionality {A : type} : WF [] Î© $ âˆ€' (ğ’« A) $ âˆ€' (ğ’« A) $ (âˆ€' A $ (â†‘0 âˆˆ â†‘2) â‡” (â†‘0 âˆˆ â†‘1)) âŸ¹ (â†‘1 â‰ƒ[ğ’« A] â†‘0)
  :=
  begin
    apply_rules WF_rules, all_goals {refl}
  end
\end{lstlisting}

This tactic is incredibly useful, and allows us to greatly reduce the size of proofs without sacrificing proof-completeness. A key example is the following inductive proof.

\subsection{Entailments Preserve Well-Formedness} \label{section:WF_proof_terms}
We prove that any proven entailment can contain only well-formed terms. Of the 24 inductive cases to be proven, 12 of them are solved automatically by lines 5 and 6.

\begin{lstlisting}[numbers=left, stepnumber=1, basicstyle=\small\ttfamily]
lemma WF.proof_terms {Î“} {p q} : entails Î“ p q â†’ WF Î“ Î© p âˆ§ WF Î“ Î© q :=
  begin
    intro ent,
    induction ent,
    any_goals {split;apply_rules WF_rules;refl},
    any_goals {split; simp * at *;apply_rules WF_rules;refl},
    case entails.and_left   : _ _ _ _ _ ih {exact âŸ¨ih.1, WF.and_left ih.2âŸ©},
    case entails.and_right  : _ _ _ _ _ ih {exact âŸ¨ih.1, WF.and_right ih.2âŸ©},
    case entails.or_left    : _ _ _ _ _ ih {split, any_goals {simp * at *},
                                            exact WF.or_left ih.1},
    case entails.or_right   : _ _ _ _ _ ih {split, any_goals {simp * at *},
                                            exact WF.or_right ih.1},
    case entails.imp_to_and : _ _ _ _ _ ih {split, apply WF.and,
                                            exact ih.1, exact WF.imp_left ih.2, 
                                            exact WF.imp_right ih.2},
    case entails.and_to_imp : _ _ _ _ _ ih {split, exact WF.and_left ih.1,
                                            apply WF.imp,
                                            exact WF.and_right ih.1, exact ih.2},
    case entails.weakening  : _ _ _ _ _ ih {split; apply WF.add_context, tidy},
    case entails.all_elim   : _ _ _ _ _ ih {exact âŸ¨WF.lift_once ih.1,
                                                    WF.all_elim ih.2âŸ©},
    case entails.all_intro  : _ _ _ _ _ ih {exact âŸ¨WF.drop ih.1, WF.all ih.2âŸ©},
    case entails.ex_elim    : _ _ _ _ _ ih {exact âŸ¨WF.lift_once ih.1, WF.ex_elim ih.2âŸ©},
    case entails.ex_intro   : _ _ _ _ _ ih {exact âŸ¨WF.drop ih.1, WF.ex ih.2âŸ©},
    case entails.sub        : Î“ B b p q wfb ent ih {
      suffices : âˆ€ p, WF (B :: Î“) Î© p â†’ WF Î“ Î© ([p // b]),
        from âŸ¨this p ih.1, this q ih.2âŸ©,
      intros _ wfp, exact WF.subst wfb wfp
    },
  end
\end{lstlisting}

\section{LITT is a category}

The Intuitionistic Type Theory we have presented has an associated category, whose construction is analagous to forming the category of sets from ZF-set theory. In the following theorem we delay the definitions of \emph{term-sets}, \emph{graphs} and their \emph{composition} until the \LITT~presentation. 

\begin{thm}
  Given an \ITT,  $\mathcal{L}$, there is an associated category $T(\mathcal{L})$, whose objects are equivalence classes of term-sets and morphisms are equivalence classes of graphs between term-sets. In both cases, equivalence is defined by provable equality of terms, that is, $\alpha$ and $\alpha'$ are equivalent iff. $\vdash \alpha = \alpha'$ (similarly for graphs). 
\end{thm}

It is possible to form equivalence classes of the relevant terms in Lean\footnote{via the \lc{quotient} construction}, but we will not present this here to simplify the presentation. Instead we work directly with closed terms, and present statements of the lemmas of equivalence.

\begin{definition}(\textbf{LITT})
  The following definitions define the relevant \emph{term-sets} \emph{graphs} and \emph{composition}. 
\begin{lstlisting}
/- Closed terms are well-formed in the empty context -/
def closed : type â†’ term â†’ Prop := WF []

/-! ### tset -/

  /- Closed terms of type ğ’« A.
    An Î± : tset A is basically a set of A's, i.e. "term-set" -/
def tset (A: type) : Type := {Î± : term // WF [] (ğ’« A) Î±} -- subtype construction

/-! ### graph -/

/- F is a tset representing the graph of a function from Î± to Î² -/
-- Note: `âŠ†[-]` and `Î± Ã— Î²` have derived meanings
def is_graph {A B: type} (Î± : tset A) (Î² : tset B) (F : tset (A Ã— B)) : Prop :=
  (âŠ¨ (F âŠ†[ğ’« A] (Î± Ã— Î²))) -- F is a subset of the product (of terms, not just types)
    âˆ§
  (âŠ¨ (âˆ€ A ((â†‘0 âˆˆ Î±) âŸ¹ (âˆƒ!' B $ âŸªâ†‘1,â†‘0âŸ« âˆˆ F)))) -- F is functional

/- The Type of graphs - defined via subtpe of tset (A Ã— B) satisfying `is_graph`-/
def graph {A B} (Î± : tset A) (Î² : tset B) : Type
  := {F : tset (A Ã— B) // is_graph Î± Î² F}

-- the identity graph
def diagonal {A} (Î± : tset A) : graph Î± Î± :=
  ( graph.mk 
    ( tset.mk (A Ã— A) ({ A Ã— A | âˆƒ A (â†‘1 â‰ƒ[A ğ• A] âŸªâ†‘0,â†‘0âŸ«)})
      (by apply_rules [WF_rules, WF.closed_add_context];refl)
    )
  ) 
  (by sorry)



/-! ### composition -/


variables {A B C D : type}
variable {Î± : tset A}
variable {Î² : tset B}
variable {Î· : tset C}
variable {Î´ : tset D}

/- The underlying term of the composition of two graphs -/
def composition_term (F : graph Î± Î²) (G : graph Î² Î·) : term :=
  { A Ã— C | -- all d : A Ã— C such that
        âˆƒ[A,C] -- âˆƒ a c,
        (
          (â†‘2 â‰ƒ[A Ã— C] âŸªâ†‘1,â†‘0âŸ«) -- d = âŸ¨a,câŸ©
         â‹€
          (âˆƒ B ((âŸªâ†‘2,â†‘0âŸ« âˆˆ F) â‹€ (âŸªâ†‘0, â†‘1âŸ« âˆˆ G))) -- âˆƒ b, âŸ¨a,bâŸ© âˆˆ F âˆ§ âŸ¨b,câŸ© âˆˆ G
        )
  }

/- The composition construction produces a closed term -/
def WF.composition (F : graph Î± Î²) (G : graph Î² Î·) : closed (ğ’« (A Ã— C)) (composition_term F G)
  := by WF_prover;refl

/- The graph which is the composition of two graphs 
Note we define F âˆ˜ G as what would usually be G âˆ˜ F (this is just the Lean convention) -/
def composition (F : graph Î± Î²) (G : graph Î² Î·) : graph Î± Î· :=
  (graph.mk (tset.mk (A Ã— C) (composition_term F G) (WF.composition F G)))
  (by sorry) -- Proof of `is_graph`
  
\end{lstlisting}
\end{definition}

We can now state the relevant theorems which demonstrate that term-sets and graphs form the relevant category $T(\mathcal{L})$. We employ this use of \lc{sorry} in Lean as a placeholder for missing proofs.

\begin{definition}(\textbf{LITT})
  \begin{lstlisting}
    /- (F âˆ˜ G) âˆ˜ H â‰ƒ F âˆ˜ (G âˆ˜ H) -/
    theorem associativity (F : graph Î± Î²) (G : graph Î² Î·) (H : graph Î· Î´) :
    âŠ¨ (composition (composition F G) H â‰ƒ[ğ’« (A Ã— D)] composition F (composition G H)) 
    := sorry
    
    /- F âˆ˜ Î”_Î² â‰ƒ F -/
    theorem comp_id (F : graph Î± Î²) : âŠ¨ composition F (diagonal Î²) â‰ƒ F
    := sorry
    
    /- Î”_Î± âˆ˜ F â‰ƒ F -/
    theorem id_comp (F : graph Î± Î²) : âŠ¨ composition (diagonal Î±) F â‰ƒ F
    := sorry
  \end{lstlisting}
\end{definition}

\section{Conclusion}

We have successfully translated Lambek and Scott's \ITT \cite{lambek_scott}, into a well-defined formal system \LITT~in Lean. In this implementation we formally defined the inductive types, \lc{type, term} of the type theory, as well as the inductive propositions \lc{WF, entails}, which reason about well-formedness and entailments of terms, and simultaenously force the intended semantic interpretation on \lc{types} and \lc{terms}. We have also circumvented the need for $\alpha$-equivalence by use of De Bruijn indices \cite{pierce}.

Lean proves to be a viable option for a more careful analysis of formal systems, such as \ITT. Being able to organise ``obvious'' lemmas as libraries of functions allows us to control the otherwise-intractable scale of formal proofs, while presenting them in a clean focused manner. Throughout we have seen the value in extending the parser to user defined notation - which greatly improves the readability of terms in proofs. Lean's tactic mode allows inherently non-linear proofs to be carried out in an interactive, goal-based procedure, allowing the programmer/mathematician to prove one goal at a time without having to manually keep track of goals.

Now that we have stated the relevant theorems needed to show that this type theory has a natural associated category, the next step is to develop the foundational libraries of ``obvious'' lemmas needed to prove these theorems - and then prove them.

\bibliographystyle{amsalpha}
\providecommand{\bysame}{\leavevmode\hbox to3em{\hrulefill}\thinspace}
\providecommand{\href}[2]{#2}
\begin{thebibliography}{9}

\bibitem{lean}
Moura, Leonardo de, Soonho Kong, Jeremy Avigad, Floris van Doorn and Jakob von Raumer. â€œThe Lean Theorem Prover.â€ (2015).

\bibitem{lambek_scott}
J.~Lambek and P.J.~Scott, \textsl{Introduction to higher-order categorical logic}, (Vol. 7). Cambridge University Press, (1988).

\bibitem{TL}
B. Price, \textsl{TL}, 2020. Github Repository. \texttt{https://github.com/billy-price/TL}
 
\bibitem{pierce}
B.C.~Pierce, \textsl{Types and Programming Languages}, MIT Press, (2002).

\bibitem{murfet}
D.~Murfet, \textsl{Topos theory and categorical logic seminar - Lecture 9 - Higher-order logic and topoi (Part 2)}, (2018).

\bibitem{carneiro}
M.~Carneiro, \textsl{The Type Theory of Lean}, 2019

\end{thebibliography}


\end{document}