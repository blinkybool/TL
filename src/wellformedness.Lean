import definitions
import tactic

def foo : â„• := 3


@[user_attribute]
meta def WF_rules : user_attribute :=
{ name := `WF_rules,
  descr := "lemmas usable to prove Well Formedness" }

namespace TT


open list
local notation lâ‚ ++ lâ‚‚ := list.append lâ‚ lâ‚‚

variables {Î“ Î” : list type}
variables {A B Î©' : type}
-- Î©' is just a fake/variable version of Î© so we don't need to bother proving
-- that it must be Î© itself.'
variables {p q r Ï† a b Î± : term}

attribute [WF_rules]
WF.star WF.top WF.bot WF.and WF.or WF.imp WF.elem WF.pair WF.var WF.comp WF.all WF.ex


lemma WF.and_elim  : WF Î“ Î©' (p â‹€ q) â†’ WF Î“ Î©' p âˆ§ WF Î“ Î©' q := by {intro h, cases h, tidy}
lemma WF.or_elim   : WF Î“ Î©' (p â‹ q) â†’ WF Î“ Î©' p âˆ§ WF Î“ Î©' q := by {intro h, cases h, tidy}
lemma WF.imp_elim  : WF Î“ Î©' (p âŸ¹ q) â†’ WF Î“ Î©' p âˆ§ WF Î“ Î©' q := by {intro h, cases h, tidy}
lemma WF.pair_elim : WF Î“ (A ğ• B) âŸªa,bâŸ« â†’ WF Î“ A a âˆ§ WF Î“ B b := by {intro h, cases h, tidy}
lemma WF.comp_elim : WF Î“ (ğ’« A) âŸ¦A | Ï†âŸ§ â†’ WF (A::Î“) Î© Ï† := by {intro h, cases h, tidy}
lemma WF.all_elim  : WF Î“ Î©' (âˆ€' A Ï†) â†’ WF (A::Î“) Î©' Ï† := by {intro h, cases h, tidy}
lemma WF.ex_elim   : WF Î“ Î©' (âˆƒ' A Ï†) â†’ WF (A::Î“) Î©' Ï† := by {intro h, cases h, tidy}

lemma WF.eq_elim {Î“} {aâ‚ aâ‚‚} {A} : WF Î“ Î© (aâ‚ â‰ƒ[A] aâ‚‚) â†’ WF Î“ A aâ‚ âˆ§ WF Î“ A aâ‚‚ := sorry

@[WF_rules]
lemma WF.iff : WF Î“ Î© p â†’ WF Î“ Î© q â†’ WF Î“ Î© (p â‡” q) := by intros; apply_rules WF_rules

@[WF_rules]
lemma WF.lift (K Î” Î“ : context) (A : type) (a : term) : WF (K ++ Î“) A a â†’ WF (K ++ Î” ++ Î“) A (lift (length Î”) (length K) a) :=
begin
  intro wfa,
  -- generalize_hyp e : K ++ Î“ = Î“' at wfa,
  induction' wfa; simp * at *,
  any_goals {apply_rules WF_rules;refl},
  any_goals {apply_rules WF_rules; {exact ih_wfa Î” <|> exact ih_wfa_1 Î”}},
  case WF.var : {
    split_ifs, sorry,
      {
        apply WF.var,
        rw â†x, simp at h, sorry,
      }
  },
  iterate 3 {sorry},
end

@[WF_rules]
lemma WF.lift_once {Î“ A a B} : WF Î“ A a â†’ WF (B :: Î“) A (^a) :=
  by {intros, apply WF.lift [] [B] Î“, assumption}

@[WF_rules]
lemma WF.eq {Î“} {aâ‚ aâ‚‚} {A} : WF Î“ A aâ‚ â†’ WF Î“ A aâ‚‚ â†’ WF Î“ Î© (aâ‚ â‰ƒ[A] aâ‚‚) :=
  by {intros; apply_rules WF_rules; refl}

lemma WF.drop {Î“ A a B} : WF (B :: Î“) A (^a) â†’ WF Î“ A a := sorry

@[simp]
lemma WF.lift_closed {A d} (a : term) : WF [] A a â†’ lift d 0 a = a :=
begin
  suffices : âˆ€ G A a, WF G A a â†’ lift d (list.length G) a = a,
  { exact this _ _ _ },
  introv wf,
  induction wf; simp * at *,
  exact if_neg (not_le_of_gt (list.nth_eq_some.1 wf_a).fst)
end

lemma WF.add_context {Î“ Î” : list type} {A a}: WF Î“ A a â†’ WF (Î“ ++ Î”) A a :=
begin
  intro wf,
  induction wf,
  case WF.var : Î“ A n eq {
    apply WF.var, erw nth_append, assumption, exact (nth_eq_some.mp eq).fst 
  },
  all_goals {apply_rules WF_rules}
end

lemma WF.closed_add_context {Î“ a A} : WF [] A a â†’ WF Î“ A a :=
  by {intro wf, rw â†nil_append Î“, exact WF.add_context wf}

lemma WF.subst {Î“ B b p} : WF Î“ B b â†’ WF (B :: Î“) Î© p â†’ WF Î“ Î© (pâ…bâ†) := sorry

lemma WF.entails_terms {Î“} {p q} : entails Î“ p q â†’ WF Î“ Î© p âˆ§ WF Î“ Î© q :=
begin
  intro ent,
  induction ent,
  case sub        : Î“ p q b B wfb ent ih {
    suffices : âˆ€ p, WF (B :: Î“) Î© p â†’ WF Î“ Î© (pâ…bâ†), from âŸ¨this p ih.1, this q ih.2âŸ©,
    intros _ wfp, exact WF.subst wfb wfp
  },
  any_goals {split; cases ent_ih.1; cases ent_ih.2; apply_rules WF_rules; tidy},
  any_goals {split;apply_rules WF_rules;refl},
  any_goals {split; simp * at *;apply_rules WF_rules;refl},
  case all_intro : Î“ p Ï† A entÏ† ih { split, apply WF.drop ih.1, apply_rules WF_rules; tidy},
  case ex_intro : Î“ p Ï† A entÏ† ih { split, apply_rules WF_rules; tidy, apply WF.drop ih.2,},
end

lemma WF.entails_left  {Î“ p q} : entails Î“ p q â†’ WF Î“ Î© p :=
  Î» ent, (WF.entails_terms ent).1
lemma WF.entails_right {Î“ p q} : entails Î“ p q â†’ WF Î“ Î© q :=
  Î» ent, (WF.entails_terms ent).2

end TT

open tactic

meta def decompose_WF : expr â†’ expr â†’ tactic expr
| _ `(TT.WF _ _ TT.term.star) := tactic.failed
| _ `(TT.WF _ _ TT.term.top) := tactic.failed
| _ `(TT.WF _ _ TT.term.bot) := tactic.failed
| h `(TT.WF _ _ (TT.term_eq _ _ _)) := mk_app `TT.WF.eq_elim [h]
| h `(TT.WF _ _ (TT.term.and _ _)) := mk_app `TT.WF.and_elim [h]
| h `(TT.WF _ _ (TT.term.or _ _)) := mk_app `TT.WF.or_elim [h]
| h `(TT.WF _ _ (TT.term.imp _ _)) := mk_app `TT.WF.imp_elim [h]
| h `(TT.WF _ _ (TT.term.pair _ _)) := mk_app `TT.WF.pair_elim [h]
| h `(TT.WF _ _ (TT.term.comp _ _)) := mk_app `TT.WF.comp_elim [h]
| h `(TT.WF _ _ (TT.term.all _ _)) := mk_app `TT.WF.all_elim [h]
| h `(TT.WF _ _ (TT.term.ex _ _)) := mk_app `TT.WF.ex_elim [h]
| h `(TT.entails _ _ _) := mk_app `TT.WF.entails_terms [h]
| _ _ := tactic.failed

meta def decompose_list_WFs : list expr â†’ tactic unit
| [] := skip
| (h::t) :=
  do
    H â† infer_type h,
    (decompose_WF h H >>= cases >>= list.mmap' (Î» name_wfs, decompose_list_WFs name_wfs.2)) <|> skip,
    decompose_list_WFs t

meta def tactic.interactive.decompose_WFs : tactic unit :=
  local_context >>= decompose_list_WFs

meta def tactic.interactive.WF_prover : tactic unit :=
  do `[tactic.interactive.decompose_WFs <|> skip, apply_rules WF_rules]

namespace TT

example {Î“ p q r} : entails Î“ q q â†’ WF Î“ Î© ((p â‹€ âŠ¤) â‹ r) â†’ WF Î“ Î© (r âŸ¹ (p â‹ q)) :=
begin
  intros entq wfpq,
  WF_prover,
end

end TT