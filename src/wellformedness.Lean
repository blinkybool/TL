import definitions
import tactic.induction
import tactic.tidy

@[user_attribute]
meta def WF_rules : user_attribute :=
{ name := `WF_rules,
  descr := "lemmas usable to prove Well Formedness" }


meta def tactic.interactive.WF_prover : tactic unit:= do `[apply_rules WF_rules]

namespace TT

open list
local notation lâ‚ ++ lâ‚‚ := list.append lâ‚ lâ‚‚

variables {Î“ Î” : list type}
variables {p q r Ï† a b Î± : term}
variables {A B Î©' : type}
-- Î©' is just a fake/variable version of Î© so we don't need to bother proving
-- that it must be Î© itself.'

attribute [WF_rules]
WF.star WF.top WF.bot WF.and WF.or WF.imp WF.elem WF.pair WF.var WF.comp WF.all WF.ex

meta def WF_cases : tactic unit := do `[intro h, cases h, assumption]

lemma WF.and_left   (p q) : WF Î“ Î©' (p â‹€ q) â†’ WF Î“ Î©' p := by WF_cases
lemma WF.and_right  (p q) : WF Î“ Î©' (p â‹€ q) â†’ WF Î“ Î©' q := by WF_cases
lemma WF.or_left    (p q) : WF Î“ Î©' (p â‹ q) â†’ WF Î“ Î©' p := by WF_cases
lemma WF.or_right   (p q) : WF Î“ Î©' (p â‹ q) â†’ WF Î“ Î©' q := by WF_cases
lemma WF.imp_left   (p q) : WF Î“ Î©' (p âŸ¹ q) â†’ WF Î“ Î©' p := by WF_cases
lemma WF.imp_right  (p q) : WF Î“ Î©' (p âŸ¹ q) â†’ WF Î“ Î©' q := by WF_cases
lemma WF.pair_left  (a b) : WF Î“ (A ğ• B) âŸªa,bâŸ« â†’ WF Î“ A a := by WF_cases
lemma WF.pair_right (a b) : WF Î“ (A ğ• B) âŸªa,bâŸ« â†’ WF Î“ B b := by WF_cases
lemma WF.comp_elim  (Ï†)   : WF Î“ (ğ’« A) âŸ¦A | Ï†âŸ§ â†’ WF (A::Î“) Î© Ï† := by WF_cases
lemma WF.all_elim   (Ï†)   : WF Î“ Î©' (âˆ€' A Ï†) â†’ WF (A::Î“) Î©' Ï† := by WF_cases
lemma WF.ex_elim    (Ï†)   : WF Î“ Î©' (âˆƒ' A Ï†) â†’ WF (A::Î“) Î©' Ï† := by WF_cases

@[WF_rules]
lemma WF.iff : WF Î“ Î© p â†’ WF Î“ Î© q â†’ WF Î“ Î© (p â‡” q) := by {intros, WF_prover}

lemma iff_elim : WF Î“ Î©' (p â‡” q) â†’ WF Î“ Î©' p âˆ§ WF Î“ Î©' q :=
  by intro h; split; cases h; apply WF.imp_left; assumption

@[WF_rules]
lemma WF.lift (K Î” Î“ : context) (A : type) (a : term) : WF (K ++ Î“) A a â†’ WF (K ++ Î” ++ Î“) A (lift (length Î”) (length K) a) :=
begin
  intro wfa,
  -- generalize_hyp e : K ++ Î“ = Î“' at wfa,
  induction' wfa; simp * at *,
  any_goals {WF_prover;refl},
  any_goals {WF_prover; {exact ih_wfa Î” <|> exact ih_wfa_1 Î”}},
  case WF.var : {
    split_ifs,
      { induction' Î”,
          { suffices : K ++ nil ++ Î“ = K ++ Î“, rw this, simp, exact WF.var x,
            suffices : K ++ nil = K, rw this, exact append_nil K },
          { 
            sorry
          }
      },
      {
        apply WF.var,
        rw â†x, simp at h, sorry,
      }
  },
  iterate 3 {sorry},
end

@[WF_rules]
lemma WF.lift_once {Î“ A a B} : WF Î“ A a â†’ WF (B :: Î“) A (^a) :=
  by {intros, apply WF.lift [] [B] Î“, assumption}

@[WF_rules]
lemma WF.eq {Î“} {aâ‚ aâ‚‚} (A : type) : WF Î“ A aâ‚ â†’ WF Î“ A aâ‚‚ â†’ WF Î“ Î© (aâ‚ â‰ƒ[A] aâ‚‚) :=
  by {intros; WF_prover; refl}

lemma WF.drop {Î“ A a B} : WF (B :: Î“) A (^a) â†’ WF Î“ A a :=
begin
  intro wfa',
  induction' wfa'; sorry
end

@[simp]
lemma WF.lift_closed {A d} (a : term) : WF [] A a â†’ lift d 0 a = a :=
begin
  suffices : âˆ€ G A a, WF G A a â†’ lift d (list.length G) a = a,
  { exact this _ _ _ },
  introv wf,
  induction wf; simp * at *,
  exact if_neg (not_le_of_gt (list.nth_eq_some.1 wf_a).fst)
end

lemma WF.add_context {Î“ Î” : list type} {A a}: WF Î“ A a â†’ WF (Î“ ++ Î”) A a :=
begin
  intro wf,
  induction wf,
  case WF.var : Î“ A n eq {
    apply WF.var, erw nth_append, assumption, exact (nth_eq_some.mp eq).fst 
  },
  all_goals {WF_prover}
end

lemma WF.closed_add_context {Î“ a A} : WF [] A a â†’ WF Î“ A a :=
  by {intro wf, rw â†nil_append Î“, exact WF.add_context wf}

lemma WF.subst {Î“ B b p} : WF Î“ B b â†’ WF (B :: Î“) Î© p â†’ WF Î“ Î© (pâ…bâ†) := sorry

lemma WF.entails_terms {Î“} {p q} : entails Î“ p q â†’ WF Î“ Î© p âˆ§ WF Î“ Î© q :=
begin
  intro ent,
  induction ent,
  any_goals {split;WF_prover;refl},
  any_goals {split; simp * at *;WF_prover;refl},
  case and_left   : _ _ _ _ _ ih {exact âŸ¨ih.1, WF.and_left _ _ ih.2âŸ©},
  case and_right  : _ _ _ _ _ ih {exact âŸ¨ih.1, WF.and_right _ _ ih.2âŸ©},
  case hyp_or_left  : _ _ _ _ _ ih {split, any_goals {simp * at *}, exact WF.or_left _ _ ih.1},
  case hyp_or_right : _ _ _ _ _ ih {split, any_goals {simp * at *}, exact WF.or_right _ _ ih.1},
  case imp_to_and : _ _ _ _ _ ih {split, apply WF.and, exact ih.1, exact WF.imp_left _ _ ih.2, exact WF.imp_right _ _ ih.2},
  case and_to_imp : _ _ _ _ _ ih {split, exact WF.and_left _ _ ih.1, apply WF.imp, exact WF.and_right _ _ ih.1, exact ih.2},
  case weakening  : p' q' K Î” Î“ ent ih { split; WF_prover; tidy},
  case all_elim   : _ _ _ _ _ ih {exact âŸ¨WF.lift_once ih.1, WF.all_elim _ ih.2âŸ©},
  case all_intro  : _ _ _ _ _ ih {exact âŸ¨WF.drop ih.1, WF.all ih.2âŸ©},
  case ex_elim    : _ _ _ _ _ ih {exact âŸ¨WF.lift_once ih.1, WF.ex_elim _ ih.2âŸ©},
  case ex_intro   : _ _ _ _ _ ih {exact âŸ¨WF.drop ih.1, WF.ex ih.2âŸ©},
  case sub        : Î“ p q B b wfb ent ih {
    suffices : âˆ€ p, WF (B :: Î“) Î© p â†’ WF Î“ Î© (pâ…bâ†), from âŸ¨this p ih.1, this q ih.2âŸ©,
    intros _ wfp, exact WF.subst wfb wfp
  },
end

lemma WF.entails_left  {Î“ p q} : entails Î“ p q â†’ WF Î“ Î© p :=
  Î» ent, (WF.entails_terms ent).1
lemma WF.entails_right {Î“ p q} : entails Î“ p q â†’ WF Î“ Î© q :=
  Î» ent, (WF.entails_terms ent).2



end TT